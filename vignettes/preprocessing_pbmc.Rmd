---
title: "Data preprocessing for TRIPOD - 10x Genomics PBMC 10k"
author: "Yuriko Harigaya, Nancy R. Zhang, Yuchao Jiang"
date: "`r format(Sys.Date())`"
output:
    html_document:
        highlight: pygments
        toc: true
bibliography: TRIPOD.bib
vignette: >
  %\VignetteIndexEntry{preprocessing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, warning = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# 1 Introduction

This is a supplement to [the TRIPOD vignette](http://htmlpreview.github.io/?https://github.com/yharigaya/TRIPOD/blob/main/vignettes/TRIPOD_pbmc.html).
Here, we demonstrate data preprocessing required for conducting
analysis using the TRIPOD package.
The input is sigle-cell ATAC/RNA multiomic data, which is publicly available from 
[10x Genomics](https://support.10xgenomics.com/single-cell-multiome-atac-gex/datasets). 
The data was generated in 11909 cells of human peripheral blood mononuclear cells (PBMCs) 
and contains ATAC-seq and RNA-seq read counts for 108377 ATAC peaks 
and 36601 gene regions, respectively.

# 2 Required packages

The TRIPOD package is available from [GitHub](https://github.com/yharigaya/TRIPOD).

```{r install, eval = FALSE, message = FALSE, warning = FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
devtools::install_github("yharigaya/TRIPOD/package")
```

```{r setup, eval = TRUE, message = FALSE}
library(TRIPOD)
```

Additionally, the following packages are required to run this vignette.

```{r packages, cache = FALSE, message = FALSE}
library(BiocParallel)
library(dplyr)
library(ggplot2)
library(patchwork)
library(Seurat)
library(SeuratDisk)
library(Signac)
library(GenomicRanges)
library(GenomeInfoDb)
library(EnsDb.Hsapiens.v86)
library(BSgenome.Hsapiens.UCSC.hg38)
library(chromVAR)
library(JASPAR2020)
library(TFBSTools)
library(motifmatchr)
```

# 3 Preprocessing
## 3.1 Creating and processing a Seurat object

We first create and process a Seurat object essentially according to the tutorial [here](https://satijalab.org/seurat/articles/weighted_nearest_neighbor_analysis.html). 
The input data (`pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5`, `pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz`, and 
`pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz.tbi`) can be downloaded 
from the 10x Genomics website
[here](https://support.10xgenomics.com/single-cell-multiome-atac-gex/datasets).

We obtain cell type labels according to the tutorial
[here](https://satijalab.org/seurat/articles/multimodal_reference_mapping.html).
The input CITE-seq data (`pbmc_multimodal_citeseq.h5seurat`) can be downloaded
[here](https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat).

In this vignette, we start with a processed Seurat object (`pbmc.chomvar.rds`),
which can be downloaded
[here](https://www.dropbox.com/s/o2d9kfgdmfsu68a/pbmc.chromvar.rds?dl=0).

## 3.2 Creating objects required for model fitting

We next create objects containing information that is necessary for model fitting, 
namely, `transcripts.gr`, `peaks.gr`, `motifxTF`, and `peakxmotif`. 
See the documentation for more detailed descriptions of these objects.

```{r, include = FALSE, eval = TRUE, message = FALSE, warning = FALSE}
# for testing on a local machine only
file <- "pbmc.chromvar.rds"
dir.pub <- "~/Dropbox/TRIPOD/public"
path <- file.path(dir.pub, file)
pbmc <- readRDS(path); rm(path)
```

```{r, eval = FALSE}
file <- "pbmc.chomvar.rds"
path <- file.path("path/to/your/dir", file)
pbmc <- readRDS(path); rm(path)
```

The `transcripts.gr` object is a GRanges object from [the GenomicRanges package](https://bioconductor.org/packages/release/bioc/html/GenomicRanges.html)
and contains chromosomal coordinates of annotated protein containing genes.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
DefaultAssay(pbmc) <- "ATAC"
transcripts.gr <- Signac:::CollapseToLongestTranscript(ranges = Annotation(pbmc))
transcripts.gr <- transcripts.gr[transcripts.gr$gene_biotype == "protein_coding"]
transcripts.gr <- transcripts.gr[seqnames(transcripts.gr) %in% 
		paste("chr", 1:22, sep = "")]
transcripts.gr <- sort(transcripts.gr)
transcripts.gr
```

The `peaks.gr` object is a GRanges object from the GenomicRanges package
and contains chromosomal coordinates of the ATAC peak regions in the multiomic
data.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
peaks.gr <- pbmc@assays$ATAC@ranges
```

The `motifxTF` object is a matrix containing mapping
between TFs and their binding motifs.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
motifxTF <- unlist(pbmc@assays$ATAC@motifs@motif.names)
motifxTF <- cbind(names(motifxTF), motifxTF)
colnames(motifxTF) <- c("motif", "TF")
```

The `peakxmotif` object is a binary sparse matrix containing indicators
as to whether a given motif is preset in a given ATAC peak region.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
peakxmotif <- pbmc@assays$ATAC@motifs@data 
peakxmotif[1:5, 1:5]
```

We only keep motifs when genes encoding corresponding TFs are present in the
RNA-seq data.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
peakxmotif <- peakxmotif[, motifxTF[, 2] %in% rownames(pbmc@assays$RNA)]
motifxTF <- motifxTF[motifxTF[, 2] %in% rownames(pbmc@assays$RNA), ]
```

We note that our current implementation
excludes cases where a TF corresponds to multiple motifs or vice versa. 
We plan to provide an option to include such degenerate cases in a future version
of the package.

## 3.3 Further filering of the data

Since the normalization step (SCTranform) do not return values for all input,
we perform further data filtering
to ensure that the same set of genes is included in all objects. 

```{r, eval = TRUE, message = FALSE, warning = FALSE}
# take the intersection of the genes
genes <- intersect(transcripts.gr$gene_name, rownames(pbmc@assays$SCT))
DefaultAssay(pbmc) <- "RNA"
pbmc@assays$RNA <- subset(pbmc@assays$RNA, 
	features = match(genes, rownames(pbmc@assays$RNA)))
pbmc@assays$SCT <- subset(pbmc@assays$SCT, 
	features = match(genes, rownames(pbmc@assays$SCT)))
transcripts.gr <- transcripts.gr[match(genes, transcripts.gr$gene_name)]
peakxmotif <- peakxmotif[, motifxTF[, 2] %in% genes]
motifxTF <- motifxTF[motifxTF[, 2] %in% genes, ]
pbmc@assays$chromvar <- subset(
	pbmc@assays$chromvar,
	features = match(motifxTF[, 1], rownames(pbmc@assays$chromvar)))
```

We then perform normalization and dimension reduction again for the filtered data.

```{r renormalization, eval = TRUE, message = FALSE, warning = FALSE}
# RNA analysis
DefaultAssay(pbmc) <- "RNA"
pbmc <- SCTransform(pbmc, verbose = FALSE) %>%
	RunPCA() %>%
	RunUMAP(dims = 1:50, reduction.name = "umap.rna", reduction.key = "rnaUMAP_")

# ATAC analysis
# exclude the first dimension as this is typically correlated with sequencing depth
DefaultAssay(pbmc) <- "ATAC"
pbmc <- RunTFIDF(pbmc) %>%
	FindTopFeatures(min.cutoff = "q0") %>%
	RunSVD() %>%
	RunUMAP(reduction = "lsi", dims = 2:50, 
		reduction.name = "umap.atac", reduction.key = "atacUMAP_")

# recalculate a WNN graph
pbmc <- FindMultiModalNeighbors(pbmc, reduction.list = list("pca", "lsi"), 
	dims.list = list(1:50, 2:50))
pbmc <- RunUMAP(pbmc, nn.name = "weighted.nn", 
	reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
```

The following code visualizes the data on recalculated graphs.

```{r, eval = TRUE, message = FALSE, warning = FALSE, fig.width = 9, fig.height = 4, fig.align = "center"}
p1 <- DimPlot(pbmc, reduction = "umap.rna",  group.by = "celltype", 
	label = TRUE, label.size = 2.5, repel = TRUE) +
	ggtitle("RNA")
p2 <- DimPlot(pbmc, reduction = "umap.atac",  group.by = "celltype", 
	label = TRUE, label.size = 2.5, repel = TRUE) +
	ggtitle("ATAC")
p3 <- DimPlot(pbmc, reduction = "wnn.umap", group.by = "celltype", 
	label = TRUE, label.size = 2.5, repel = TRUE) +
	ggtitle("WNN")
p1 + p2 + p3 & NoLegend() & theme(plot.title = element_text(hjust = 0.5))
```

## 3.4 Partitioning single cells into metacells

To alleviate the issue of sparsity of the single cell data, we next partition the cells
into clusters, which we call metacells. The models in the TRIPOD package are
based on metacells, not single cells. Cells can be clustered based on either the ATAC
or RNA modality. It is also possible to use the weighted nearest neighbor (WNN) method [@Hao2021].
For the PBMC data, we use the WNN method.

To obtain a set of metacells suited for model fitting, it is necessary to select
an optimal resolution of clustering to ensure the following.

* a sufficient number of cells per metacell for resolving the sparsity issue
* a sufficient number of metacells to allow for model fitting

Our empirical approach is to select a resolution that gives 80 or more metacells,
the majority of which contain 20 or more single cells. For this purpose, 
we first construct a shared nearest neighbor graph.

Based on the graph, we then perform clustering at several resolutions.
The following code generates a data frame containing the resolutions,
the number of resultant clusters, and the number of clusters with fewer than
threshold number of single cells. The threshold is set to 20 cells.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
num.clusters <- optimizeResolution(
	object = pbmc,
	graph.name = "wsnn",
	assay.name = "WNN",
	resolutions = seq(10, 35, 5),
	min.num = 20
)
num.clusters
```

Based on the above analysis, we select the resolution of 15.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
res <- 15
pbmc <- FindClusters(pbmc, graph.name = "wsnn", algorithm = 3,
    	resolution = res, verbose = FALSE)
```

In our procedure, the factor levels need to be in an ascending numerical order.
The following code shows that the factors are in a desirable order.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
levels(pbmc$wsnn_res.15)
```

If the factor levels were not ordered properly, they could be reorderd using the following code.

```{r, eval = FALSE, message = FALSE, warning = FALSE}
tmp <- as.character(pbmc$wsnn_res.15)
levels.15 <- as.character(sort(as.numeric(levels(pbmc$wsnn_res.15))))
tmp <- factor(tmp, levels = levels.15)
pbmc$wsnn_res.15 <- tmp
```

We then overwrite
the `seurat_cluster` column with the `wsnn_res.15` column.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
pbmc@meta.data$seurat_clusters <- pbmc@meta.data$wsnn_res.15
pbmc@meta.data$wsnn_res.15 <- NULL
```

We now obtain matrices containing normalized RNA expression and chromatin accessibility per metacell using the `getMetacellMatrix` function. 

```{r, eval = TRUE, message = FALSE, warning = FALSE}
metacell.rna <- getMetacellMatrix(
	object = pbmc,
  cluster = "seurat_clusters",
	assay = "RNA")

metacell.peak <- getMetacellMatrix(
	object = pbmc,
  cluster = "seurat_clusters",
	assay = "ATAC")
```

It is necessary to save the Seurat object (`pbmc`) for running [the TRIPOD vignette](http://htmlpreview.github.io/?https://github.com/yharigaya/TRIPOD/blob/main/vignettes/TRIPOD_pbmc.html)
since the object is not included in the TRIPOD package.

```{r, eval = FALSE}
file <- "pbmc.rds"
path <- file.path("path/to/your/dir", file)
saveRDS(pbmc, path); rm(path)
```

## 3.5 Assigning cell types and colors for visualization

For visualization purposes, it is convenient to assign colors to cell types
and create objects storing mapping between them. For this purpose, 
we first assign cell types to metacells.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
metacell.celltype <- getCellTypeForMetacell(pbmc,
	celltype.col.name = "celltype", cluster.col.name = "seurat_clusters")
```

We then assign colors to cell types. The following code generates a mapping 
between cell types and colors for single cells.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
sc.color.map <- getColorsForSingleCells(
	object = pbmc, reduction = "umap.rna", celltype.col.name = "celltype")
head(sc.color.map)
```

The following code creates a mapping between cell types and colors for metacells.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
metacell.color.map <- getColorsForMetacells(
	metacell.celltype = metacell.celltype, sc.color.map = sc.color.map)
metacell.celltype.col <- metacell.color.map$color 
head(metacell.color.map)
```

It is also convenient to have a mapping between cell types and colors
themselves.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
color.map <- getColors(ordered.celltypes = levels(droplevels(pbmc$celltype)),
	metacell.color.map = metacell.color.map)
color.map
```

## 3.6 Getting a list of target genes

We typically run model fitting for top-ranked highly variable genes (HVGs)
identified by Seurat. The following code gives a ordered list of top 3000 HVGs.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
# obtain highly variable genes based on SCT
DefaultAssay(pbmc) <- "SCT"
head(VariableFeatures(pbmc))
length(VariableFeatures(pbmc))
hvg <- VariableFeatures(pbmc)
```

# Session information

```{r, eval = TRUE}
sessionInfo()
```

# References

